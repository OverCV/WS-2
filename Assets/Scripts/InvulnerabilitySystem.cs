using UnityEngine;
using System.Collections;

public class InvulnerabilitySystem : MonoBehaviour
{
    [Header("Invulnerability Settings")]
    public bool isInvulnerable = false;
    public float invulnerabilityDuration = 5.0f;
    
    [Header("Visual Feedback")]
    private Renderer[] playerRenderers;
    private Color[] originalColors;
    private bool isFlashing = false;
    
    private Coroutine invulnerabilityCoroutine;
    
    void Start()
    {
        // Get all renderers for visual feedback (optional)
        playerRenderers = GetComponentsInChildren<Renderer>();
        if (playerRenderers.Length > 0)
        {
            originalColors = new Color[playerRenderers.Length];
            for (int i = 0; i < playerRenderers.Length; i++)
            {
                if (playerRenderers[i].material != null)
                {
                    originalColors[i] = playerRenderers[i].material.color;
                }
            }
        }
    }
    
    /// <summary>
    /// Activates invulnerability for the specified duration
    /// </summary>
    public void ActivateInvulnerability()
    {
        // If already invulnerable, extend the duration
        if (invulnerabilityCoroutine != null)
        {
            StopCoroutine(invulnerabilityCoroutine);
            Debug.Log("Invulnerabilidad extendida");
        }
        
        // Start invulnerability
        invulnerabilityCoroutine = StartCoroutine(InvulnerabilityCoroutine());
    }
    
    /// <summary>
    /// Coroutine that handles the invulnerability timer and visual effects
    /// </summary>
    private IEnumerator InvulnerabilityCoroutine()
    {
        // Activate invulnerability
        isInvulnerable = true;
        Debug.Log("¡Invulnerabilidad activada! Duración: " + invulnerabilityDuration + " segundos");
        
        // Start visual feedback
        StartVisualFeedback();
        
        // Wait for duration
        yield return new WaitForSeconds(invulnerabilityDuration);
        
        // Deactivate invulnerability
        isInvulnerable = false;
        Debug.Log("Invulnerabilidad terminada");
        
        // Stop visual feedback
        StopVisualFeedback();
        
        // Clear coroutine reference
        invulnerabilityCoroutine = null;
    }
    
    /// <summary>
    /// Starts visual feedback for invulnerability (color flashing)
    /// </summary>
    private void StartVisualFeedback()
    {
        if (!isFlashing && playerRenderers.Length > 0)
        {
            isFlashing = true;
            StartCoroutine(FlashEffect());
        }
    }
    
    /// <summary>
    /// Stops visual feedback and restores original colors
    /// </summary>
    private void StopVisualFeedback()
    {
        isFlashing = false;
        
        // Restore original colors
        for (int i = 0; i < playerRenderers.Length; i++)
        {
            if (playerRenderers[i] != null && playerRenderers[i].material != null)
            {
                playerRenderers[i].material.color = originalColors[i];
            }
        }
    }
    
    /// <summary>
    /// Creates a flashing effect while invulnerable
    /// </summary>
    private IEnumerator FlashEffect()
    {
        float flashInterval = 0.2f;
        Color flashColor = Color.cyan; // Invulnerability color
        
        while (isFlashing && isInvulnerable)
        {
            // Flash to invulnerability color
            SetPlayerColors(flashColor);
            yield return new WaitForSeconds(flashInterval);
            
            // Flash back to original colors
            if (isFlashing && isInvulnerable)
            {
                SetPlayerColors(originalColors);
                yield return new WaitForSeconds(flashInterval);
            }
        }
    }
    
    /// <summary>
    /// Sets all player renderer colors
    /// </summary>
    /// <param name="colors">Array of colors to apply</param>
    private void SetPlayerColors(Color[] colors)
    {
        for (int i = 0; i < playerRenderers.Length && i < colors.Length; i++)
        {
            if (playerRenderers[i] != null && playerRenderers[i].material != null)
            {
                playerRenderers[i].material.color = colors[i];
            }
        }
    }
    
    /// <summary>
    /// Sets all player renderer colors to a single color
    /// </summary>
    /// <param name="color">Color to apply to all renderers</param>
    private void SetPlayerColors(Color color)
    {
        for (int i = 0; i < playerRenderers.Length; i++)
        {
            if (playerRenderers[i] != null && playerRenderers[i].material != null)
            {
                playerRenderers[i].material.color = color;
            }
        }
    }
    
    /// <summary>
    /// Manually stops invulnerability (for testing or special cases)
    /// </summary>
    public void StopInvulnerability()
    {
        if (invulnerabilityCoroutine != null)
        {
            StopCoroutine(invulnerabilityCoroutine);
            invulnerabilityCoroutine = null;
        }
        
        isInvulnerable = false;
        StopVisualFeedback();
        Debug.Log("Invulnerabilidad detenida manualmente");
    }
    
    /// <summary>
    /// Returns remaining invulnerability time (for UI or debugging)
    /// </summary>
    /// <returns>Remaining time in seconds, 0 if not invulnerable</returns>
    public float GetRemainingTime()
    {
        // This would require tracking elapsed time, simplified for now
        return isInvulnerable ? invulnerabilityDuration : 0f;
    }
    
    /// <summary>
    /// Clean up coroutines when object is destroyed
    /// </summary>
    void OnDestroy()
    {
        if (invulnerabilityCoroutine != null)
        {
            StopCoroutine(invulnerabilityCoroutine);
        }
    }
}